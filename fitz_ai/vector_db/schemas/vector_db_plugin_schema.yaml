# fitz_ai/vector_db/schemas/vector_db_plugin_schema.yaml
#
# Master Schema for Vector Database YAML Plugins
# =============================================
#
# This schema defines the structure that all HTTP-based vector DB plugins
# must follow. Drop a conforming YAML file into fitz_ai/vector_db/plugins/
# and it will work automatically with GenericVectorDBPlugin.
#
# For local plugins (like FAISS), use connection.type: local and specify
# operations.python_class instead of HTTP operations.
#
# Version: 1.0.0
# Last Updated: 2025-01-15

# =============================================================================
# REQUIRED ROOT FIELDS
# =============================================================================

# name: string (required)
# Unique identifier for this plugin. Used in get_vector_db_plugin("name").
# Example: "qdrant", "pinecone", "weaviate"
name: <plugin_name>

# type: string (required)
# Must be "vector_db" for vector database plugins.
type: vector_db

# description: string (optional)
# Human-readable description of the plugin.
description: <description of the vector database>

# =============================================================================
# FEATURES SECTION
# =============================================================================
# Provider-specific features that drive loader behavior.

features:
  # requires_uuid_ids: boolean (default: false)
  # If true, string IDs will be converted to deterministic UUIDs.
  # Qdrant requires UUIDs; Pinecone/Weaviate accept any string.
  requires_uuid_ids: false

  # auto_detect: string | null (default: null)
  # Service name for auto-detection via fitz_ai.core.detect.
  # Set to "qdrant" to use get_qdrant_connection(), etc.
  # Set to null for cloud services that don't support auto-detection.
  auto_detect: null

  # supports_namespaces: boolean (default: false)
  # If true, collections are implemented as namespaces within an index.
  # Pinecone uses this pattern.
  supports_namespaces: false

# =============================================================================
# CONNECTION SECTION
# =============================================================================
# How to connect to the vector database.

connection:
  # type: "http" | "local" (required)
  # "http" - HTTP API-based vector DB (uses GenericVectorDBPlugin)
  # "local" - Local library (delegates to Python class)
  type: http

  # base_url: string (required for HTTP)
  # Jinja2 template for the base URL. Available variables:
  # - {{host}}: Host from kwargs or default_host
  # - {{port}}: Port from kwargs or default_port
  # - {{environment}}: Cloud region/environment
  # - {{index_name}}: Index name (Pinecone)
  # - {{project_id}}: Project ID (Pinecone)
  base_url: "http://{{host}}:{{port}}"

  # Default values used if not provided in kwargs
  default_host: localhost
  default_port: 6333
  default_environment: null

  # auth: object (optional)
  # Authentication configuration
  auth:
    # type: "bearer" | "custom" | "none"
    # "bearer" - Authorization: Bearer <token> (or custom scheme)
    # "custom" - Custom header with just the key
    # "none" - No authentication required
    type: bearer

    # env_var: string (required if type != none)
    # Environment variable containing the API key.
    env_var: VECTOR_DB_API_KEY

    # header: string (default: "Authorization")
    # HTTP header name for the auth token.
    header: Authorization

    # scheme: string (default: "Bearer")
    # Auth scheme prefix. Only used with type: bearer.
    scheme: Bearer

    # optional: boolean (default: false)
    # If true, missing API key won't raise an error.
    # Useful for local deployments that don't require auth.
    optional: false

# =============================================================================
# OPERATIONS SECTION
# =============================================================================
# HTTP operations the plugin supports.
# Each operation defines endpoint, method, body template, and response parsing.

operations:
  # ---------------------------------------------------------------------------
  # search: Search for similar vectors (REQUIRED)
  # ---------------------------------------------------------------------------
  search:
    # endpoint: string (required)
    # URL path, supports Jinja2 templates.
    # Available variables: collection, query_vector, limit, with_payload, + kwargs
    endpoint: /collections/{{collection}}/points/search

    # method: string (required)
    # HTTP method: GET, POST, PUT, DELETE
    method: POST

    # body: object (optional)
    # Request body template. Values are Jinja2 templates.
    # Use "{{variable}}" for direct substitution.
    body:
      vector: "{{query_vector}}"
      limit: "{{limit}}"
      with_payload: "{{with_payload}}"

    # response: object (required)
    # How to parse the response.
    response:
      # results_path: string (required)
      # Dot-notation path to the results array in the response.
      results_path: result

      # mapping: object (required)
      # Maps standard fields to provider-specific paths within each result.
      mapping:
        id: id              # Path to document ID
        score: score        # Path to similarity score
        payload: payload    # Path to metadata/payload

  # ---------------------------------------------------------------------------
  # upsert: Insert or update points (REQUIRED)
  # ---------------------------------------------------------------------------
  upsert:
    endpoint: /collections/{{collection}}/points
    method: PUT

    # auto_create_collection: boolean (default: false)
    # If true, automatically creates collection on 404.
    auto_create_collection: true

    # create_collection_endpoint: string (required if auto_create_collection)
    # Endpoint to create the collection.
    create_collection_endpoint: /collections/{{collection}}

    # create_collection_method: string (default: PUT)
    create_collection_method: PUT

    # create_collection_body: object (optional)
    # Body template for collection creation.
    # Available variable: {{vector_dim}} - detected from first point.
    create_collection_body:
      vectors:
        size: "{{vector_dim}}"
        distance: Cosine

    body:
      points: "{{points}}"

    # point_transform: object (optional)
    # Transform standard point format to provider-specific format.
    # Standard format: {id, vector, payload}
    # Set identity: true if provider uses same format.
    point_transform:
      identity: true
      # OR specify field mapping:
      # id: id
      # values: vector
      # metadata: payload

  # ---------------------------------------------------------------------------
  # count: Get point count in collection (OPTIONAL)
  # ---------------------------------------------------------------------------
  count:
    endpoint: /collections/{{collection}}
    method: GET
    response:
      # count_path: string (required)
      # Path to the point count in the response.
      count_path: result.points_count

  # ---------------------------------------------------------------------------
  # create_collection: Explicitly create a collection (OPTIONAL)
  # ---------------------------------------------------------------------------
  create_collection:
    endpoint: /collections/{{collection}}
    method: PUT
    body:
      vectors:
        size: "{{vector_size}}"
        distance: Cosine

  # ---------------------------------------------------------------------------
  # delete_collection: Delete a collection (OPTIONAL)
  # ---------------------------------------------------------------------------
  delete_collection:
    endpoint: /collections/{{collection}}
    method: DELETE
    response:
      # success_codes: list[int] (default: [200])
      # HTTP status codes that indicate success.
      # Include 404 if "already deleted" should be considered success.
      success_codes: [200, 404]

  # ---------------------------------------------------------------------------
  # list_collections: List all collections (OPTIONAL)
  # ---------------------------------------------------------------------------
  list_collections:
    endpoint: /collections
    method: GET
    response:
      # collections_path: string (required)
      # Path to the collections array in the response.
      collections_path: result.collections

      # name_field: string (default: "name")
      # Field within each collection object containing the name.
      name_field: name

  # ---------------------------------------------------------------------------
  # get_stats: Get collection statistics (OPTIONAL)
  # ---------------------------------------------------------------------------
  get_stats:
    endpoint: /collections/{{collection}}
    method: GET
    response:
      # stats_path: string (required)
      # Path to the stats object in the response.
      stats_path: result

# =============================================================================
# LOCAL PLUGINS (ALTERNATIVE)
# =============================================================================
# For local vector databases that don't use HTTP APIs (e.g., FAISS),
# set connection.type: local and use python_class instead of HTTP operations.
#
# Example:
#
# connection:
#   type: local
#
# operations:
#   python_class: fitz_ai.backends.local_vector_db.pgvector.PgVectorDB

# =============================================================================
# EXAMPLE: MINIMAL PLUGIN
# =============================================================================
# Here's a minimal valid plugin definition:
#
# name: my_vector_db
# type: vector_db
# description: My custom vector database
#
# features:
#   requires_uuid_ids: false
#
# connection:
#   type: http
#   base_url: "http://{{host}}:{{port}}"
#   default_host: localhost
#   default_port: 8080
#
# operations:
#   search:
#     endpoint: /search
#     method: POST
#     body:
#       query: "{{query_vector}}"
#       k: "{{limit}}"
#     response:
#       results_path: results
#       mapping:
#         id: id
#         score: score
#         payload: metadata
#
#   upsert:
#     endpoint: /upsert
#     method: POST
#     body:
#       vectors: "{{points}}"
#     point_transform:
#       identity: true