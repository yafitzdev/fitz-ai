# fitz_ai/ingestion/enrichment/config.py
"""
Configuration schema for the enrichment pipeline.

All retrieval intelligence is BAKED IN - no opt-in configuration needed.

Enrichment automatically provides:
1. Chunk-level: summary, keywords, entities (via unified enrichment bus)
2. Hierarchy-level: L1 group summaries, L2 corpus summary
3. Project-level: artifacts (auto-detected plugins)

The enrichment bus batches chunks efficiently (~15 per LLM call), making
the cost negligible even for large codebases.

Config structure in .fitz/config.yaml:
    enrichment:
      enabled: true  # Master switch (default: true)
      hierarchy:
        group_by: source_file  # How to group chunks for L1 summaries
      artifacts:
        auto: true
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any


@dataclass
class ArtifactConfig:
    """
    Configuration for project-level artifacts.

    Artifacts are high-level project summaries generated by plugins.
    Each plugin declares which content types it supports. Plugins are
    auto-discovered from the artifacts/plugins/ directory.

    Attributes:
        auto: Auto-discover and run all applicable plugins
        enabled: Explicit list of plugins to run (overrides auto)
        disabled: Plugins to skip even if applicable
    """

    auto: bool = True
    enabled: list[str] = field(default_factory=list)
    disabled: list[str] = field(default_factory=list)


@dataclass
class HierarchyRule:
    """
    A single hierarchy rule for grouping and summarizing chunks.

    Users configure rules to enable multi-level summarization of content.
    Chunks matching the path patterns are grouped by a metadata key, and
    LLM summaries are generated at group and corpus levels.

    Attributes:
        name: Unique identifier for this rule (e.g., "video_comments")
        paths: Glob patterns to filter files (e.g., ["comments/**", "*.txt"])
        group_by: Metadata key to group chunks by (e.g., "video_id")
        prompt: LLM prompt for generating group-level summaries
        corpus_prompt: Optional prompt for corpus-level summary
    """

    name: str
    paths: list[str]
    group_by: str
    prompt: str
    corpus_prompt: str | None = None


@dataclass
class HierarchyConfig:
    """
    Configuration for hierarchical enrichment.

    Hierarchical enrichment generates multi-level summaries:
    - Level 0: Original chunks (unchanged)
    - Level 1: Group summaries (chunks grouped by metadata key or semantic similarity)
    - Level 2: Corpus summary (summary of all groups)

    Zero-config mode (recommended):
        Just set enabled=True or use `fitz ingest --hierarchy`.
        Uses smart defaults: group_by="source", default prompts.

    Semantic grouping mode:
        Set grouping_strategy="semantic" to cluster chunks by embedding similarity.
        Requires embedder to be provided.

    Power-user mode:
        Configure custom rules for complex grouping scenarios.

    Attributes:
        grouping_strategy: "metadata" (default) or "semantic" for embedding-based clustering
        group_by: Metadata key for grouping (used when strategy is "metadata")
        n_clusters: Number of clusters for semantic grouping (None = auto-detect)
        max_clusters: Maximum clusters for auto-detection
        group_prompt: Custom prompt for group summaries (optional)
        corpus_prompt: Custom prompt for corpus summary (optional)
        rules: Advanced rules for power users (optional, overrides simple mode)
    """

    # No enabled field - hierarchy is always on
    grouping_strategy: str = "metadata"  # "metadata" or "semantic"
    group_by: str = "source_file"  # Default: each file is a group (metadata mode)
    n_clusters: int | None = None  # For semantic grouping (None = auto-detect)
    max_clusters: int = 10  # Upper bound for auto-detection
    group_prompt: str | None = None  # Uses DEFAULT_GROUP_PROMPT if None
    corpus_prompt: str | None = None  # Uses DEFAULT_CORPUS_PROMPT if None
    rules: list[HierarchyRule] = field(default_factory=list)  # Power user


@dataclass
class EnrichmentConfig:
    """
    Configuration for the enrichment pipeline.

    All chunk-level enrichment (summary, keywords, entities) is BAKED IN
    via the unified enrichment bus. No opt-in configuration needed.

    Attributes:
        enabled: Master switch for all enrichment
        artifacts: Project-level artifact configuration
        hierarchy: Hierarchical summarization configuration

    Example in .fitz/config.yaml:
        enrichment:
          enabled: true
          artifacts:
            auto: true
            disabled:
              - architecture_narrative
          hierarchy:
            group_by: source_file
            rules:
              - name: video_comments
                paths: ["comments/**"]
                group_by: video_id
                prompt: "Summarize sentiment and themes"
    """

    enabled: bool = True  # Master switch
    artifacts: ArtifactConfig = field(default_factory=ArtifactConfig)
    hierarchy: HierarchyConfig = field(default_factory=HierarchyConfig)

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "EnrichmentConfig":
        """Create config from dictionary (e.g., from YAML)."""
        if not data:
            return cls()

        artifacts_data = data.get("artifacts", {})
        hierarchy_data = data.get("hierarchy", {})

        # Parse hierarchy rules
        hierarchy_rules = []
        for rule_data in hierarchy_data.get("rules", []):
            hierarchy_rules.append(
                HierarchyRule(
                    name=rule_data.get("name", "unnamed"),
                    paths=rule_data.get("paths", []),
                    group_by=rule_data.get("group_by", ""),
                    prompt=rule_data.get("prompt", "Summarize this group."),
                    corpus_prompt=rule_data.get("corpus_prompt"),
                )
            )

        return cls(
            enabled=data.get("enabled", True),
            artifacts=ArtifactConfig(
                auto=artifacts_data.get("auto", True),
                enabled=artifacts_data.get("enabled", []),
                disabled=artifacts_data.get("disabled", []),
            ),
            hierarchy=HierarchyConfig(
                grouping_strategy=hierarchy_data.get("grouping_strategy", "metadata"),
                group_by=hierarchy_data.get("group_by", "source_file"),
                n_clusters=hierarchy_data.get("n_clusters"),
                max_clusters=hierarchy_data.get("max_clusters", 10),
                group_prompt=hierarchy_data.get("group_prompt"),
                corpus_prompt=hierarchy_data.get("corpus_prompt"),
                rules=hierarchy_rules,
            ),
        )

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "enabled": self.enabled,
            "artifacts": {
                "auto": self.artifacts.auto,
                "enabled": self.artifacts.enabled,
                "disabled": self.artifacts.disabled,
            },
            "hierarchy": {
                "grouping_strategy": self.hierarchy.grouping_strategy,
                "group_by": self.hierarchy.group_by,
                "n_clusters": self.hierarchy.n_clusters,
                "max_clusters": self.hierarchy.max_clusters,
                "group_prompt": self.hierarchy.group_prompt,
                "corpus_prompt": self.hierarchy.corpus_prompt,
                "rules": [
                    {
                        "name": rule.name,
                        "paths": rule.paths,
                        "group_by": rule.group_by,
                        "prompt": rule.prompt,
                        "corpus_prompt": rule.corpus_prompt,
                    }
                    for rule in self.hierarchy.rules
                ],
            },
        }


__all__ = [
    "EnrichmentConfig",
    "ArtifactConfig",
    "HierarchyConfig",
    "HierarchyRule",
]
