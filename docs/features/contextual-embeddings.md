# Contextual Embeddings

## Problem

Chunks are embedded in isolation, losing document context:

```
Original document: "TechCorp Authentication System - JWT Tokens"
Chunk content:     "It expires after 24 hours and must be refreshed."
```

When this chunk is embedded alone:
- "It" has no referent
- No indication this is about JWT tokens
- No connection to TechCorp or authentication
- Query "JWT token expiration" may not match well

## Solution: Summary-Prefixed Embeddings

Prepend the chunk's summary (generated during enrichment) to the content before embedding:

```
Summary:    "JWT token expiration and refresh mechanism in TechCorp auth system."
Content:    "It expires after 24 hours and must be refreshed."

Embedded:   "JWT token expiration and refresh mechanism in TechCorp auth system.

            It expires after 24 hours and must be refreshed."
```

Now the embedding captures:
- What "it" refers to (JWT token)
- The domain (authentication)
- The source (TechCorp)

## How It Works

### At Ingestion Time

1. Document is parsed and chunked
2. **Enrichment** generates a summary for each chunk (already happening)
3. Summary is stored in `chunk.metadata["summary"]`
4. **Embedding** prepends summary to content: `f"{summary}\n\n{content}"`
5. Combined text is embedded and stored

### No Query-Time Changes

Queries are embedded normally. The improved chunk embeddings provide better semantic matches without any retrieval changes.

## Implementation

The change is minimal - just use the summary that's already generated:

```python
# ingestion_pipeline.py
def _get_embedding_text(self, chunk: Chunk) -> str:
    summary = chunk.metadata.get("summary", "")
    if summary:
        return f"{summary}\n\n{chunk.content}"
    return chunk.content

vectors = [self.embedder.embed(self._get_embedding_text(c)) for c in chunks]
```

## Key Design Decisions

1. **Zero additional cost** - Summaries are already generated by enrichment pipeline.

2. **Graceful fallback** - If no summary exists, embed content alone.

3. **Content preserved** - Original `chunk.content` unchanged for display/generation.

4. **Both pipelines** - Works in both `IngestionPipeline` and `DiffIngestExecutor`.

## Files

- **Implementation:** `fitz_ai/ingestion/pipeline/ingestion_pipeline.py`
- **Diff executor:** `fitz_ai/ingestion/diff/executor.py`
- **Summary generation:** `fitz_ai/ingestion/enrichment/modules/chunk/summary.py`

## Benefits

| Without Contextual | With Contextual |
|--------------------|-----------------|
| "It expires in 24h" embedded alone | "JWT token expiration... It expires in 24h" |
| Pronouns have no referent | Pronouns resolved via summary |
| Topic unclear | Topic explicit in embedding |
| Weaker semantic match | Stronger semantic match |

## Example

**Query:** "How long are JWT tokens valid?"

**Chunk content:** "It expires after 24 hours and must be refreshed using the refresh token endpoint."

**Without contextual embeddings:**
- Embedding: "It expires after 24 hours..."
- Match quality: Moderate (no "JWT" in embedding)

**With contextual embeddings:**
- Embedding: "JWT token expiration and refresh mechanism in TechCorp auth system.\n\nIt expires after 24 hours..."
- Match quality: Strong ("JWT" + "token" + "expires" all present)

## Performance

- No additional LLM calls (summaries already generated)
- Slightly larger text to embed (~50-100 extra tokens per chunk)
- Embedding cost increase: ~10-20%
- Retrieval quality improvement: Significant for ambiguous chunks

## Requirements

- Enrichment must be enabled to generate summaries
- Re-ingestion required for existing documents to benefit

## References

- [Anthropic: Contextual Retrieval](https://www.anthropic.com/news/contextual-retrieval) - Original technique description
