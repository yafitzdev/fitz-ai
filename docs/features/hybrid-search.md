# Hybrid Search (Dense + Sparse)

## Problem

Dense (semantic) search excels at understanding meaning but can miss exact keyword matches:

- "X100 specs" - Dense search might retrieve Y200 docs if semantically similar
- "CCS Combo 1 charging" - Technical identifiers need exact matching
- "SAE Level 2+" - Acronyms might embed differently than their expansions

## Solution: Hybrid Search with RRF Fusion

Combine dense (semantic) and sparse (TF-IDF keyword) search using Reciprocal Rank Fusion:

```
Dense search:  [doc_A, doc_B, doc_C, ...]  (semantic similarity)
Sparse search: [doc_C, doc_D, doc_A, ...]  (keyword matching)
                        ↓
                   RRF Fusion
                        ↓
Combined:      [doc_A, doc_C, doc_B, doc_D, ...]  (best of both)
```

## How It Works

### At Ingestion

1. Chunks are stored with dense embeddings in PostgreSQL (pgvector)
2. Chunks get a `content_tsv` column auto-generated by PostgreSQL tsvector
3. Both dense and sparse indices are maintained automatically - no configuration needed

### At Query Time

1. Query is embedded (dense vector)
2. Query is tokenized via PostgreSQL `plainto_tsquery()`
3. Both vector similarity and full-text search run in parallel
4. Results are fused using Reciprocal Rank Fusion (RRF)

### RRF Formula

```
score(doc) = Σ 1/(k + rank_i(doc))
```

Where:
- `k` = constant (default 60, higher = more weight to lower ranks)
- `rank_i(doc)` = rank of doc in retrieval method i (1-indexed)

A document appearing at rank 1 in both dense and sparse gets:
- RRF score = 1/(60+1) + 1/(60+1) = 0.0328

A document at rank 1 in dense but rank 100 in sparse gets:
- RRF score = 1/(60+1) + 1/(60+100) = 0.0226

## Key Design Decisions

1. **Always-on** - Baked into VectorSearchStep. No plugin configuration.

2. **Native PostgreSQL** - Uses PostgreSQL's built-in full-text search (tsvector) for sparse matching.

3. **Zero maintenance** - tsvector column is auto-generated and auto-indexed by PostgreSQL.

4. **Built at ingestion** - Full-text index is created via `GENERATED ALWAYS AS` column.

5. **Per-collection database** - Each collection has its own PostgreSQL database with full-text enabled.

## Configuration

No configuration required. Feature is baked into the retrieval pipeline and PostgreSQL schema.

Internal parameters in `VectorSearchStep`:
- `rrf_k`: RRF constant (default: 60)

PostgreSQL tsvector configuration:
- Language: `english` (configurable per collection)
- Auto-generated from `payload->>'content'`
- GIN index for fast full-text lookup

## Files

- **pgvector backend:** `fitz_ai/backends/local_vector_db/pgvector.py`
- **Schema:** `chunks` table with `content_tsv tsvector GENERATED ALWAYS AS ...`
- **Query integration:** `fitz_ai/engines/fitz_rag/retrieval/steps/vector_search.py` (`_hybrid_search`)

## Benefits

| Dense Only | Hybrid (Dense + Sparse) |
|------------|-------------------------|
| Misses exact keywords | Catches exact matches |
| Semantic similarity only | Semantic + lexical |
| Acronyms may fail | Acronyms work well |
| Model numbers fuzzy | Model numbers exact |

## Example

**Query:** "X100 battery capacity"

**Dense search top-5:**
1. "The Model X100 is TechCorp's mid-range sedan..."
2. "Model Y200 features a 100 kWh battery..."
3. "Battery technology: lithium-ion cells..."

**Sparse search top-5:**
1. "Model X100: Battery capacity: 75 kWh"
2. "The Model X100 is TechCorp's mid-range sedan..."
3. "X100 pricing and specifications..."

**After RRF fusion:**
1. "Model X100: Battery capacity: 75 kWh" (exact keyword match boosted)
2. "The Model X100 is TechCorp's mid-range sedan..."
3. "X100 pricing and specifications..."

## Dependencies

- PostgreSQL + pgvector (unified storage)
- Full-text search via PostgreSQL's built-in tsvector
- No additional Python dependencies for sparse search
